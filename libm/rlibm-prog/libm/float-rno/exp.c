#include <math.h>
#include "float-rno/float_rno_lib.h"
#include "exp2.h"

double rlibm_rno_exp(float x) {
  float_x fx;
  fx.f = x;
  
  // Take care of special cases
  if ((fx.x & 0x7FFFFFFF) == 0) return 1.0;

  if (fx.x <= 872415231) {
    if (fx.x <= 864026623) return 1.0000000298023223876953125;
    return 1.0000000894069671630859375;
  }

  if (1118925336 <= fx.x && fx.x <= 3011510272) {
    if (fx.x < 0x80000000) {
      if (fx.x < 0x7F800000) return 3.40282361850336062550457001444955389952e+38;
      if (fx.x == 0x7F800000) return 1.0 / 0.0;
      return 0.0/0.0;
    }
    
    // negative counterpart
    if (fx.x <= 3003121664) return 0.99999998509883880615234375;
    
    return 0.99999995529651641845703125;
  }

  if (fx.x >= 3268407733) {
    if (fx.x == 0xFF800000) return 0.0;
    if (fx.x < 0xFF800000) return ldexp(1.0, -151);
    return 0.0/0.0;
  }
  
  // Perform range reduction
  double xp = x * 92.332482616893656768297660164535045623779296875;
  int N = (int)xp;
  int N2 = N % 64;
  if (N2 < 0) N2 += 64;
  int N1 = N - N2;
  
  int M = N1 / 64;
  int J = N2;
  double R = x - N *
  0.01083042469624914509729318723429969395510852336883544921875;
  
  double_x dX;
  dX.d = R;
  double y;
  switch (dX.x) {
    case 0xbf6f925ff5140000:
      y = 9.961534403895146994045717292465269565582275390625e-01;
      break;
    case 0xbf262097d5680000:
      y = 9.9983119621919913644347843728610314428806304931640625e-01;
      break;
    case 0x3e8fffffc0000000:
      y = 1.0000001788139345482164799250313080847263336181640625;
      break;
    case 0x3e9fffff80000000:
      y = 1.0000004172325136497789799250313080847263336181640625;
      break;
    case 0x3eafffff00000000:
      y = 1.0000008940696718529039799250313080847263336181640625;
      break;
    case 0x3eb7fffee0000000:
      y = 1.0000013709068300560289799250313080847263336181640625;
      break;
    case 0x3ebffffe00000000:
      y = 1.0000018477439882591539799250313080847263336181640625;
      break;
    case 0x3ec7fffdc0000000:
      y = 1.0000028014183046654039799250313080847263336181640625;
      break;
    case 0x3ecffffc00000000:
      y = 1.0000037550926210716539799250313080847263336181640625;
      break;
    case 0x3ed3fffce0000000:
      y = 1.0000047087669374779039799250313080847263336181640625;
      break;
    case 0x3ed7fffb80000000:
      y = 1.0000056624412538841539799250313080847263336181640625;
      break;
    case 0x3edbfff9e0000000:
      y = 1.0000066161155702904039799250313080847263336181640625;
      break;
    case 0x3edffff800000000:
      y = 1.0000075697898866966539799250313080847263336181640625;
      break;
    case 0x3ee3fff9c0000000:
      y = 1.0000094771385195091539799250313080847263336181640625;
      break;
    case 0x3f8113e28d466000:
      y = 1.0083735419018842183191964068100787699222564697265625;
      break;
    default:
      // Compute polynomial
      y = 8.5474794112503672816050226401785039342939853668212890625e-03;
      y *= R;
      y += 4.166671173299595076766621559727354906499385833740234375e-02;
      y *= R;
      y += 1.66666642121591213054898616974242031574249267578125e-01;
      y *= R;
      y += 5.000000000021367352331935762776993215084075927734375e-01;
      y *= R;
      y += 1.0000000000004687361609967410913668572902679443359375;
      y *= R;
      y += 1.0000000000000002220446049250313080847263336181640625;
  }
  // Perform output compensation
  y *= ldexp(exp2JBy64[J], M);
  return y;
}
